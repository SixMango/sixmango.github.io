<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于前端缓存优化</title>
      <link href="2020/12/30/cache-optimization/"/>
      <url>2020/12/30/cache-optimization/</url>
      
        <content type="html"><![CDATA[<p>在浏览器通过DNS域名解析获取到IP地址后，在发送请求时会先进行缓存检测。</p><blockquote><p>缓存位置：</p><ul><li>Memory Cache：内存缓存</li><li>Disk Cache：硬盘缓存</li></ul></blockquote><p>打开网页：查找disk cache中是否有匹配，有则使用</p><p>普通刷新(F5)：网页没有关闭，优先使用memory cache，其次使用disk cache</p><p>强制刷新(Ctrl + F5)：不使用缓存，请求头设置Cache-control:no-cache</p><h2 id="强缓存-Expires-Cache-Control"><a href="#强缓存-Expires-Cache-Control" class="headerlink" title="强缓存 Expires / Cache-Control"></a>强缓存 Expires / Cache-Control</h2><p>浏览器对于强缓存的处理，根据第一次请求资源时返回的响应头来确定的</p><ul><li>Expires：缓存过期时间,用来指定资源到期的时间(HTTP/1.0)</li><li>Cache-Control：cache-control:max-age=2592000第一次拿到资源后的259200秒内(30天),再次发送请求,读取缓存中的信息(HTTP/1.1)</li><li>两者同时存在的话, Cache-Control优先级高于Expires</li></ul><blockquote><p>HTML页面一般不做强缓存，以便获取的html数据最新</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果服务器文件更新了，但本地存在强缓存，这种情况是拿不到最新内容的，可以通过以下方法解决</p><p>1）服务器更新资源后，让资源名称和之前不一样，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index. dads 3232. js</span><br><span class="line">index. fsdfsddvd js</span><br></pre></td></tr></table></figure><p>可以使用webpack打包工具中设置hash name</p><p>2）当文件更新后,我们在htm倒入的时候,设置个后缀(时间戳)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;index. js?a&#x3D;312312321&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;index js?a&#x3D;898989888&quot;&gt;</span><br></pre></td></tr></table></figure><p>3）使用协商缓存</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>强缓存要比协商缓存性能高（不必总是向服务器发请求）</p><h2 id="协商缓存-Last-Modified-ETag"><a href="#协商缓存-Last-Modified-ETag" class="headerlink" title="协商缓存 Last-Modified / ETag"></a>协商缓存 Last-Modified / ETag</h2><p>协商缓存在强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否需要更新</p><ul><li>Last-Modified：资源文件最后更新的时间(HTTP/1.0)</li><li>ETag：记录资源的一个标识，每一次资源更新都会重新生成一个Etag(HTTP/1.1)</li><li>两者同时存在的话, ETag优先级高于Last-Modified</li></ul><p>浏览器将信息和标识缓存到本地，再次发起请求时在请求头中携带</p><p>If-Modifhed-Since：Last-Modified</p><p>If-None-Match：ETag</p><p><strong>强缓存和协商缓存主要用作静态资源文件，一般不经常更新</strong></p><h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><p>使用sessionStorage/localStorage或者vuex/redux等，将通过Ajax获取到的数据进行存储。</p><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>在做DNS解析时会先查找本地是否有缓存。</p><blockquote><p>每一次DNS解析时间预计在20~120毫秒</p><ul><li>减少DNS请求次数</li><li>DNS预获取( DNS Prefetch)</li></ul></blockquote><p>由于要保持高可用，高并发。提供不同数据的服务会部署在不同的服务器上，所以也会导致DNS解析消耗的时间增加，这种情况可以使用DNS预获取。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//static.36obuyimg.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//d3.cn&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//djd.com&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现0.5px边框</title>
      <link href="2020/12/16/border0-5px/"/>
      <url>2020/12/16/border0-5px/</url>
      
        <content type="html"><![CDATA[<p>html结构如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="单边框"><a href="#单边框" class="headerlink" title="单边框"></a>单边框</h2><h3 id="border-border-image-linear-gradient"><a href="#border-border-image-linear-gradient" class="headerlink" title="border + border-image + linear-gradient"></a>border + border-image + linear-gradient</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">background-clip</span>: content-box;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-image</span>: <span class="built_in">linear-gradient</span>(to bottom,red <span class="number">50%</span>,transparent <span class="number">50%</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方法有一个问题，必须设置background-clip为content-box，不然边框颜色设置了透明，会显示div的背景颜色（如果没有显示背景颜色没有问题）。但因为设置了background-clip，如果再设置padding，padding部分就不会显示背景颜色，有弊端。</p><h3 id="伪元素-background-image-linear-gradient"><a href="#伪元素-background-image-linear-gradient" class="headerlink" title="伪元素 + background-image + linear-gradient"></a>伪元素 + background-image + linear-gradient</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom,red <span class="number">50%</span>, transparent <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法只是改变渐变颜色显示部分，以实现显示上的0.5px</p><h3 id="伪元素-background-color-transform"><a href="#伪元素-background-color-transform" class="headerlink" title="伪元素 + background-color + transform"></a>伪元素 + background-color + transform</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过缩放实现0.5px的边框。</p><h2 id="多边框"><a href="#多边框" class="headerlink" title="多边框"></a>多边框</h2><h3 id="伪元素-border-transfrom"><a href="#伪元素-border-transfrom" class="headerlink" title="伪元素+ border + transfrom"></a>伪元素+ border + transfrom</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>) <span class="built_in">translate</span>(-<span class="number">1px</span>,-<span class="number">1px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> border </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器知识随笔</title>
      <link href="2020/12/02/browser/"/>
      <url>2020/12/02/browser/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器的构成"><a href="#浏览器的构成" class="headerlink" title="浏览器的构成"></a>浏览器的构成</h2><p>浏览器简单结构可以分为用户界面、浏览器引擎、渲染引擎（常被称为浏览器内核）。用户界面用于展示除标签页窗口之外的其他用户界面内容。渲染引擎负责渲染用户请求的页面内容。在用户界面和渲染引擎之间有个浏览器引擎，用于在用户界面和渲染引擎之间传递数据。</p><p>渲染引擎下面还有很多小的功能模块，比如负责网络请求的网络模块，用于解析和执行js的js解释器，解析HTML用到的XML解析器，用于绘制基本的浏览器窗口内控件的UI后端，还有数据存储持久层，帮助浏览器保存各种数据，比如cookie等等。<br><img src="https://ae01.alicdn.com/kf/U470190e3982246ec89d2e71a06bcfe2ar.jpg"></p><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>不同浏览器使用的内核也不近相同，下表做了个总结</p><table><thead><tr><th>浏览器</th><th>内核</th><th align="left">备注</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td align="left">IE、猎豹安全、360极速浏览器、百度浏览器</td></tr><tr><td>Firefox</td><td>Gecko</td><td align="left">Mozila自主研发的渲染引擎</td></tr><tr><td>Safari</td><td>Webkit</td><td align="left">Safari推出时使用的渲染引擎，后来将webkit开源</td></tr><tr><td>Chrome</td><td>Blink</td><td align="left">Chromium 项目（基于webkit，同时也开源）中研发的新一代渲染引擎</td></tr><tr><td>Opera</td><td>Blink</td><td align="left">最初使用自主研发的Presto（最后版本12.17），后转用Chromium 项目</td></tr><tr><td>Edge</td><td>Blink</td><td align="left">最初使用自主研发的EdgeHTML，后转用Chromium 项目（2020年四月）</td></tr></tbody></table><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Chrome浏览器是一个多进程结构应用，根据服务功能不同可以拆分成浏览器进程（负责与浏览器其他进程协调工作）、网络进程（负责发起接受网络请求）、GPU进程（负责图形渲染）、插件进程（负责控制网站使用的插件，如flash）、缓存进程（负责数据持久化）、渲染进程（负责渲染Tab标签内的内容）等等。默认情况下浏览器会为每个标签页都创建一个进程，因为chrome默认使用的进程模型是Process-per-site-instance，除此之外还有三种模型，详情参考<a href="https://www.chromium.org/developers/design-documents/process-models%E3%80%82">https://www.chromium.org/developers/design-documents/process-models。</a></p><blockquote><p>进程（Process）是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体。<br>线程（Thread）是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。<br>当启动某个程序时，就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里。当应用关闭时，该内存空间就会被回收。进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递某些数据，则需要通过进程间通信管道IPC来传递。很多应用程序都是多进程的结构，这样是为了避免某一个进程卡死，由于进程间相互独立，这样不会影响到整个应用程序。</p></blockquote><p>Chrome在不同硬件条件的设备上，会整合一些服务进程到同一进程，以达到更好的表现效果。<br><img src="https://ae01.alicdn.com/kf/Ud8ecc32ebc9a4ea998ed64236fa3c112K.jpg"></p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>导航栏的工作是由浏览器进程控制，浏览器进程又对这些工作进一步划分，使用不同线程进行处理：</p><ul><li>ui thread：控制浏览器上的按钮及输入框</li><li>network thread：处理网络请求，从网上获取数据</li><li>storage thread：控制文件等的访问</li></ul><p>当在浏览器地址栏中输入内容获得页面内容时，浏览器大致可以分为以下几步：</p><ol><li><p>处理输入</p><p>ui thread判断用户输入的是url还是query</p></li><li><p>开始导航</p><p>如果输入的是url，ui thread会启动一个network thread来获取数据。如果输入是query，就会使用默认配置的搜索引擎来查询，同时ui thread控制tab展现spinner表示正在加载中。</p><p>network thread会执行DNS查询，随后为请求建立TLS连接。</p><p>如果network thread接收到了重定向请求头如301，network thread会通知ui thread服务器要求重定向，之后另外一个url请求会被触发。</p></li><li><p>读取响应</p><p>当请求响应返回的时候，network thread会依据Content-Type及MIME Type判断响应内容的格式，如果响应内容的格式是HTML ，会把这些数据传递给renderer process。</p><p>Safe Browsing检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，network thread会展示一个警告页。</p></li><li><p>查找渲染进程</p><p>network thread确认浏览器可以导航到请求网页，network thread会通知ui thread数据已经准备好，ui thread会查找到一个renderer process进行网页的渲染。</p><blockquote><p>ui thread可以在发送url请求给network thread时，并行预先查找和启动一个渲染进程，以提高效率。</p></blockquote></li><li><p>确认导航</p><p>browser process会给renderer process发送IPC消息来确认导航，一旦browser process收到renderer process的渲染确认消息，导航过程结束，页面加载过程开始，此时地址栏会更新，历史也会更新，可通过返回键返回页面。</p><p>直到渲染结束，renderer process会通知browser process，ui thread会停止展示tab中的spinner。</p></li></ol><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程:</p><ul><li>主线程 Main thread</li><li>合成器线程 Compositor thread</li><li>栅格线程 Raster thread</li></ul><p><img src="https://ae01.alicdn.com/kf/Ud5a1b6f3c01741e3b467491039acb867L.jpg"></p><p>浏览器渲染过程：</p><ol><li><p>构建 DOM</p><p>主线程对HTML进行Tokeniser标记化，通过词法分析，将输入HTML内容解析成多个标记，根据识别后的标记进行dom tree构造，在dom tree构造过程中会创建document对象，然后以document为根节点的dom tree不断进行修改，向其中添加各种元素。</p><p>渲染html为DOM的方法由HTML Standard定义。</p></li><li><p>加载次级的资源</p><p>网页中常常包含诸如图片，CSS，JS等额外的资源，这些资源需要从网络上或者cache中获取。主进程可以在构建DOM的过程中会逐一请求它们，为了加速preload scanner会同时运行，如果在html中存在img，link等标签，preload scanner会把这些请求传递给browser process中的network thread进行相关资源的下载。</p></li><li><p>JS 的下载与执行</p><p>当遇到script标签时，主线程会停止解析HTML，而去加载，解析和执行JS代码，停止 解析html的原因在于JS可能会改变dom tree（使用诸如 document.write()等API）。</p><p>因此要把script标签放在合适的位置，或者使用async或defer属性来异步加载执行js。</p></li><li><p>样式计算</p><p>仅仅渲染dom tree还不足以获知页面的具体样式，主进程还会基于CSS选择器解析CSS获取每一个节点的最终的计算样式值。即使不提供任何CSS，浏览器对每个元素也会有一个默认的样式。</p></li><li><p>获取布局</p><p>想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局是找到所有元素的几何关系的过程。</p><p>通过遍历DOM及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的layout tree。layout tree和dom tree类似，但是其中只包含页面可见的元素，如果一个元素设置了display:none ，这个元素不会出现在layout tree上，伪元素虽然在dom tree上不可见，但是在layout tree上是可见的。</p></li><li><p>绘制各元素</p><p>即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历layout tree以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。</p></li><li><p>合成帧</p><p>复合（compositing）是一种分割页面为不同的图层，并单独栅格化，随后组合为帧的技术。不同层的组合由合成器线程完成。</p><p>主线程会遍历layout tree来创建layer tree，添加了will-change CSS属性的元素，会被看做单独的一层。</p><p>一旦layer tree被创建，渲染顺序被确定，主线程会把这些信息传递给合成器线程，合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此合成器线程将它们分成多个图块，并将每个图块发送给栅格线程，栅格线程会栅格化每一个并存储在GPU显存中。</p><p><img src="https://ae01.alicdn.com/kf/U9f8a9d38dd6e414e9733dbc591a0cad7f.jpg"></p><p>一旦磁贴被光栅化，合成器线程会收集称为“drow quards”的图块信息以创建合成帧。</p><p>合成帧随后会通过IPC消息传递给浏览器进程，由于浏览器的UI改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给GPU用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给GPU。</p><p><img src="https://ae01.alicdn.com/kf/U7a357d789bbe4db282a07e38b3269c590.jpg"></p></li></ol><p><strong>重排</strong>：当改变元素尺寸位置属性时，会重新进行样式计算，布局和绘制<br><strong>重绘</strong>：当改变元素颜色属性时，只会发生样式计算和绘制<br>如果在运行动画时，还有大量的js任务需要执行，因为布局绘制和js的执行都是在主线程运行的，当在一帧的时间内，布局和绘制结束后，还有剩余时间，js就会拿到主线程的使用权，如果js执行时间过长就会导致在下一帧开始时，js没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面动画的卡顿。我们可以使用俩种方法优化该问题。</p><ol><li>使用requestAnimationFrame这个API来帮助我们解决这个问题，该方法会在每一帧被调用，通过这个方法的回调参数，我们可以知道每一帧当前还剩余的时间，在时间用完前，让js归还主线程。</li><li>使用css中的transform属性，通过该属性实现的动画，不会经过布局和绘制，而是直接运行在合成器线程和栅格线程中，所以不会受到主线程中js执行的影响。更重要的是 transform的动画，由于不需要经过布局绘制样式计算，所以节省了很多运算时间。</li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>浏览器通过对不同事件的处理来满足各种交互需求。在浏览器的看来用户的所有手势都是输入，鼠标滚动，悬置，点击等等都是事件。</p><p>事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。</p><p><img src="https://ae01.alicdn.com/kf/Ucf4a42cc097a4f57b8ebd64e00c163a0W.jpg"></p><p>如果页面中没有绑定相关事件，合成器线程可以独立于主线程创建合成帧平滑的处理滚动。如果页面绑定了滚动事件处理器，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为非快速滚动区域（non-fast scrollable region），如果存在这个标注，合成器线程会把发生在此处的事件发送给主线程，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。</p><p><img src="https://ae01.alicdn.com/kf/U57f4f5da0c634feab8c7e0d29a8df8c5C.jpg"></p><p>web开发中常用的事件处理模式是事件委托，基于事件冒泡，常常在最顶层绑定事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, </span><br><span class="line">event =&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (event.target === area) &#123;</span><br><span class="line"> event.preventDefault();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这样整个页面都成了non-fast scrollable region，这意味着即使操作的是页面无绑定事件处理器的区域，每次输入时，合成器线程也需要和主线程通信并等待反馈，流畅的合成器独立处理合成帧的模式就失效了。</p><p><img src="https://ae01.alicdn.com/kf/U34b6b8c7c535431fb3eef28c5ecb4bc6W.jpg"></p><p>为了防止这种情况，可以为事件处理器传递passive: true做为参数，这样写就能让浏览器即监听相关事件，又让合成器线程在等主线程响应前构建新的组合帧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, </span><br><span class="line">event =&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (event.target === area) &#123;</span><br><span class="line"> event.preventDefault()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;, &#123;<span class="attr">passive</span>: <span class="literal">true</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>不过上述写法可能又会带来另外一个问题，假设某个区域你只想要水平滚动，使用passive: true可以实现平滑滚动，但是垂直方向的滚动可能会先于event.preventDefault()发生，此时可以通过event.cancelable来防止这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;pointermove&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (event.cancelable) &#123;</span><br><span class="line"> event.preventDefault(); <span class="comment">// block the native scroll</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do what you want the application to do here</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;, &#123;<span class="attr">passive</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><p>也可以使用css属性touch-action来完全消除事件处理器的影响，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#area</span> &#123; </span><br><span class="line"> <span class="attribute">touch-action</span>: pan-x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找到事件对象</strong></p><p>当合成器线程发送输入事件给主线程时，主线程首先会进行命中测试（hit test）来查找对应的事件目标，命中测试会基于渲染过程中生成的绘制记录（paint records）查找事件发生坐标下存在的元素。</p><p><img src="https://ae01.alicdn.com/kf/U46e15d3968894f44a794eeddb7280201l.jpg" alt=" "></p><p><strong>事件的优化</strong></p><p>一般屏幕的刷新速率为60fps，但是某些事件的触发量会不止这个值，出于优化的目的，Chrome 会合并连续的事件 (如wheel,mousewheel,mousemove,pointermove,touchmove)，并延迟到下一帧渲染时候执行。</p><p>而如keydown,keyup,mouseup,mousedown,touchstart和touchend等非连续性事件则会立即被触发。</p><p><img src="https://ae01.alicdn.com/kf/U02cafd088b2246ca8c819922af24aa8d3.jpg"></p><p>合并事件虽然能提示性能，但是如果你的应用是绘画等，则很难绘制一条平滑的曲线了，此时可以使用getCoalescedEvents API来获取组合的事件。示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pointermove&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> events = event.getCoalescedEvents();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> event <span class="keyword">of</span> events) &#123;</span><br><span class="line"> <span class="keyword">const</span> x = event.pageX;</span><br><span class="line"> <span class="keyword">const</span> y = event.pageY;</span><br><span class="line"> <span class="comment">// draw a line using x and y coordinates.</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/Ued062288b36f42f3b3e4e4385e0c1c5f9.jpg"></p><p>文章主要参照:</p><ul><li><a href="https://developers.google.cn/web/updates/2018/09/inside-browser-part1">https://developers.google.cn/web/updates/2018/09/inside-browser-part1</a></li><li><a href="https://developers.google.cn/web/updates/2018/09/inside-browser-part2">https://developers.google.cn/web/updates/2018/09/inside-browser-part2</a></li><li><a href="https://developers.google.cn/web/updates/2018/09/inside-browser-part3">https://developers.google.cn/web/updates/2018/09/inside-browser-part3</a></li><li><a href="https://developers.google.cn/web/updates/2018/09/inside-browser-part4">https://developers.google.cn/web/updates/2018/09/inside-browser-part4</a></li></ul><p>以及一些网上资料</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TIM个人文件夹设置</title>
      <link href="2020/11/15/tim-personal-folder/"/>
      <url>2020/11/15/tim-personal-folder/</url>
      
        <content type="html"><![CDATA[<p>QQ轻聊版、TIM版有个BUG：</p><p>如果电脑上之前没有安装过QQ完整版（比如我新装的虚拟机），那么QQ轻聊版、TIM版里面，设置修改个人文件夹位置将无法生效。在QQ轻聊版、TIM版设置界面修改个人文件夹位置后，会提示转移数据文件，之后会重启轻聊版/TIM，但重启后的登录界面上没有之前登录过的QQ号，重新输入QQ号和密码登录后，查看配置界面，发现个人文件夹位置还是修改之前的默认路径（通常是在我的文档下）。</p><ol><li>打开轻聊版/TIM设置界面，找到个人文件夹设置的地方，点击“打开个人文件夹”按钮，会打开当前的个人文件夹，完全退出轻聊版/TIM。</li><li>到个人文件夹的上一层目录，把里面的QQ号码文件夹和All Users文件夹移动或复制到新的个人文件夹位置，比如<strong>D:\MyQQData</strong>目录下。</li><li>进入”C:\Users\Public\Documents\Tencent\QQ”目录（如果没有这个目录，请自行创建），在该目录下右键新建文本文件，并重命名为“UserDataInfo.ini”</li><li>双击打开“UserDataInfo.ini”文件，将下列内容复制粘贴进去，<strong>UserDataSavePath=D:\MyQQData</strong> 这里就是指定新的个人文件夹位置，保存并关闭。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[UserDataImportSet]</span><br><span class="line">NeedImport&#x3D;0</span><br><span class="line">OldVersion&#x3D;</span><br><span class="line">OldVerDataPathType&#x3D;</span><br><span class="line">OldVerDataPath&#x3D;</span><br><span class="line">OldQQInstallPath&#x3D;C:\Program Files (x86)\Tencent\QQ</span><br><span class="line">[UserDataSet]</span><br><span class="line">UserDataSavePathType&#x3D;2</span><br><span class="line">UserDataSavePath&#x3D;D:\MyQQData</span><br><span class="line">NewVersion&#x3D;</span><br></pre></td></tr></table></figure><ol start="5"><li>重新启动轻聊版/TIM，打开配置界面，看到修改已经生效了。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个博客</title>
      <link href="2020/11/10/my-blog/"/>
      <url>2020/11/10/my-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><blockquote><p>记载通过卢克的视频学习到的东西，视频链接<a href="https://www.bilibili.com/video/BV1dt4y1Q7UE">https://www.bilibili.com/video/BV1dt4y1Q7UE</a></p></blockquote><ol><li>hexo博客搭建</li><li>github静态网站部署</li><li>通过github的Action自动部署项目</li></ol><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><table><thead><tr><th>相关说明\名称</th><th>Hexo</th><th>VuePress</th><th>Gatsby</th></tr></thead><tbody><tr><td>难易度</td><td>1</td><td>2</td><td>3</td></tr><tr><td>技术栈</td><td>ejs/stylus</td><td>vue/stylus</td><td>react/graphQL</td></tr><tr><td>主题丰富度</td><td>3</td><td>1</td><td>2</td></tr><tr><td>插件</td><td>3</td><td>1</td><td>3</td></tr><tr><td>功能性</td><td>1</td><td>2</td><td>3</td></tr><tr><td>github stars</td><td>30.8k</td><td>16.9k</td><td>45.6k</td></tr></tbody></table><p>hexo:<a href="https://hexo.bootcss.com/">https://hexo.bootcss.com/</a><br>vuepress:<a href="https://www.vuepress.cn/">https://www.vuepress.cn/</a><br>gatsby:<a href="https://www.gatsbyjs.org/">https://www.gatsbyjs.org/</a></p><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul><li>新手   Hexo</li><li>Vue   VuePress</li><li>React   Gatsby</li><li>自己造轮子~</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>基本功能</li><li>github pages</li><li>自动化部署</li><li>在线编辑</li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote><p>tips：初始化超慢… 建议翻墙~</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>整体的目的就是把项目提交到git上后在做配置<br>github有两种方式</p><ul><li><p>方式一：https://[username].github.io 仓库名必须是[username].github.io 打包产物master分支 一般用于主页<br>ps:比如我的用户名是SixMango，那么我创建的仓库名叫 sixmango.github.io (不区分大小写)，因为这样才会把该项目作为二级域名下的根，不明白先操作就知道啦~</p></li><li><p>方式二：https://[username].github.io/[repo] 可以自定义仓库名称， 一般用于小项目demo</p></li></ul><p><strong>命令行自动化部署</strong></p><ol><li>创建仓库 - 创建github上对应的仓库</li><li>添加依赖 - yarn add hexo-deployer-git   添加deply模块化与git做关联</li><li>修改配置 - _config.yml的deploy文件</li><li>执行命令  npm/yarn run deploy  把生成的解压public文件夹下的文件会全量覆盖目标库~ </li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:SixMango/sixmango.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>上面已经可以完成通过命令完成博客更新了</p><p><strong>github的Action更新后自动部署</strong></p><p>下面完成的是通过github的Action完成自动化部署，就是提交代码后自动发布，类似webhook</p><ol><li>创建一个my-blog的分支</li><li>创建 .github\workflows\deploy.yml  ps：windows手动创建带点的文件会出现特殊字符创建不了  用cmd命令窗口切换到当前目录  运行 mkdir .github\workflows\</li><li>创建deploy.yml文件  内容如下  意思是说  检查，运行什么命令，怎么部署，api文档在github的每个项目里面action选项里面有</li><li>提交代码，后  修改下文章后提交my-blog分支，去gitlib上看actions的运行是否正常执行</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">🛎️</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span> <span class="comment"># If you&#x27;re using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Install</span> <span class="string">and</span> <span class="string">Build</span> <span class="string">🔧</span> <span class="comment"># This example project is built using npm and outputs the result to the &#x27;build&#x27; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">CI:</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">        <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">🚀</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">main</span> <span class="comment"># The branch the action should deploy to.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br></pre></td></tr></table></figure><h2 id="在线编辑"><a href="#在线编辑" class="headerlink" title="在线编辑"></a>在线编辑</h2><p>通过修改ejs的模板加一个编辑的超链接<br>ps：利用github自己的编辑功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;你的项目编辑页面链接不要后缀&lt;%- page.source %&gt;&quot;</span>&gt;</span>编辑/a&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zero </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
